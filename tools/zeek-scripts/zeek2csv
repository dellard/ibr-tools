#!/usr/bin/env python3

# CODEMARK: nice-ibr
#
# Copyright (C) 2020-2024 - Raytheon BBN Technologies Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
#
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
#
# Distribution Statement "A" (Approved for Public Release,
# Distribution Unlimited).
#
# This material is based upon work supported by the Defense
# Advanced Research Projects Agency (DARPA) under Contract No.
# HR001119C0102.  The opinions, findings, and conclusions stated
# herein are those of the authors and do not necessarily reflect
# those of DARPA.
#
# In the event permission is required, DARPA is authorized to
# reproduce the copyrighted material for use as an exhibit or
# handout at DARPA-sponsored events and/or to post the material
# on the DARPA website.
#
# CODEMARK: end

"""
Read lines of a zeek connection log from stdin, extract information about the
"IBR" connections, and print them in CSV format.

The CSV format mimics the output format created by pcap2csv or cpcap2csv, but
has fewer fields (because there is less information in a zeek connection log
than in a pcap file, usually).

fields and their meaning:

saddr - the source address
daddr - the destination address
proto - the IP protocol number (TCP, UDP, or ICMP)
sport - the source port (or 0, if the protocol does not have sport)
dport - the destination port (or 0, if the protocol does not have dport)
protchksum - always -1 (not supported by zeek2csv)
iptotlen - length of the IP packet
ipid - always -1 (not supported by zeek2csv)
ttl - always -1 (not supported by zeek2csv)
ts_date - always -1 (not supported by zeek2csv)
ts_epoch - the packet timestamp, as a floating point number, measured
        from the epoch

"""

import argparse
import ipaddress
import re
import sys


def zeek2csv(args, subnet_names):
    """
    The subnet_names are the CIDR names of the subnets
    that are considered.  Only connections into these
    subnets are used, and connections out of these subnets
    are ignored.
    """

    svc2proto = {
            'icmp': 1,
            'tcp': 6,
            'udp': 17,
            }

    monitored_subnets = [
            ipaddress.IPv4Network(name) for name in subnet_names]

    for line in sys.stdin:

        # quick hack: will work for another few decades.
        # Discard any lines that don't start with a '1' or '2'
        # because they are definitely not valid dates.  Skip
        # these because they are probably zeek comment lines.
        #
        if not re.match('^[12]', line):
            continue

        tokens = line.strip().split()

        # drop IPv6
        #
        # Perhaps due to the way Zeek treats IPv4 encapsulation,
        # it is possible to one of the saddr/daddr be IPv6 but
        # not the other, so we need to check both
        #
        if (':' in tokens[2]) or (':' in tokens[4]):
            continue

        if not args.all_flows:
            src_pcnt = int(tokens[16])
            dst_pcnt = int(tokens[18])

            if args.established_flows:
                # We're only looking for "established" flows, so discard
                # any connections with less than 4 packets in either
                # direction.  (this heuristic is arbitrary and may need
                # some improvement...)
                #
                if src_pcnt < 4 and dst_pcnt < 4:
                    continue
            else:
                # We're only looking for single-packet events, so discard
                # any connections with more than one source pkt or more than
                # zero destination pkts
                #
                if src_pcnt != 1 or dst_pcnt != 0:
                    continue

        saddr = ipaddress.IPv4Address(tokens[2])
        if not args.internal_srcs:
            # if the source address is within one of the monitored
            # subnets, then ignore it; we are only interested in
            # inbound connections
            #
            for subnet in monitored_subnets:
                if saddr in subnet:
                    saddr = None
                    break

        if saddr is None:
            continue

        daddr = ipaddress.IPv4Address(tokens[4])
        if not args.external_dsts:
            # if the destination address NOT within one of the monitored
            # subnets, then we're seeing something that we should ignore
            # (such as chatter between the local routers), so ignore it
            #
            tmp_daddr = daddr
            daddr = None
            for subnet in monitored_subnets:
                if tmp_daddr in subnet:
                    daddr = tmp_daddr
                    break

        if daddr is None:
            continue

        # if we reach this point, it's a connection we should record
        #
        if tokens[6] in svc2proto:
            proto = svc2proto[tokens[6]]
        else:
            proto = 0

        src_bcnt = int(tokens[17])

        print('%d,%d,%d,%d,%d,-1,%d,-1,-1,-1,%f' % (
                saddr, daddr, proto, int(tokens[3]), int(tokens[5]),
                src_bcnt, float(tokens[0])))

def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--internal-srcs', dest='internal_srcs',
        default=False, action='store_true',
        help='Include flows from internal addresses [default=%(default)s]')
    parser.add_argument(
        '--external-dsts', dest='external_dsts',
        default=False, action='store_true',
        help='Include flows to external addresses [default=%(default)s]')
    parser.add_argument(
        '--all-flows', dest='all_flows',
        default=False, action='store_true',
        help='Include all flows (not just IBR) [default=%(default)s]')
    parser.add_argument(
        '--established-flows', dest='established_flows',
        default=False, action='store_true',
        help='Include established flows (not IBR) [default=%(default)s]')
    parser.add_argument(
        'subnet_names', nargs='+', help="Monitored subnets")


    return parser.parse_args()


def main():

    args = parse_args()

    zeek2csv(args, args.subnet_names)

if __name__ == '__main__':
    main()
